# Simple >>> complejo

### Todo gira en torno a la misma idea

{% embed url="https://en.wikipedia.org/wiki/KISS_principle" %}
Principio de diseño: los sistemas funcionan mejor si se mantienen simples
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/You_aren't_gonna_need_it" %}
No añadas funcionalidad hasta que sea estrictamente necesario
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Don't_repeat_yourself" %}
Toda pieza del software tiene un sitio único
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Feature_creep" %}
'fatiga de funcionalidad' nos lleva al software de relleno
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Software_bloat" %}
'software de relleno': Sucesivas versiones del software lo hacen cada vez más lento.
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Bert_Lance#If_it_ain't_broke,_don't_fix_it" %}
"Si funciona, no lo toques"
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/MoSCoW_method" %}
Técnica de priorización: Must - Should - Could - Won't have
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Muntzing" %}
Técnica de reducir elementos a los mínimos imprescindibles&#x20;
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Overengineering" %}
Solución sobre-complicada
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Worse_is_better" %}
Calidad del software no va de la mano de cantidad de features
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Unix_philosophy" %}
minimalismo y módulos.
{% endembed %}

{% embed url="https://en.wikipedia.org/wiki/Minimalism_(computing)" %}
Usar los mínimos recursos necesarios
{% endembed %}
